#!/usr/bin/python3
#
# Translate Yonk configuration to Vyatta one
#
# Copyright (c) 2014-2021 Alexei A. Smekalkine <ikle@ikle.ru>
#
# SPDX-License-Identifier: BSD-2-Clause
#

import json, os, sys

def json_load (path):
	print (path)

	with open (path, encoding = 'utf-8') as f:
		return json.load (f)

def escape (s):
	if isinstance (s, str):
		fmt = str.maketrans ({'"': '\\"', '\\': '\\\\'})

		return '"' + s.translate (fmt) + '"'

	return s

def vyatta_type (node):
	core = 'txt'

	if 'enum' in node:
		return core

	if not 'type' in node:
		return core

	mapping = {
		'number':	'u32',
		'name':		'name',
		'macaddr':	'macaddr',
		'ipv4-address':	'ipv4',
		'ipv6-address':	'ipv6',
		'ip-address':	'ipv4, ipv6',
		'ipv4-network':	'ipv4net',
		'ipv6-network':	'ipv6net',
		'ip-network':	'ipv4net, ipv6net'
	}

	return mapping[node['type']] if node['type'] in mapping else core

def write_ref (f, node):
	if not 'ref' in node:
		return

	f.write ('ref:')

	for n in node['ref']:
		f.write (' ' + n)

	f.write ('\n')

def get_limits (node):
	if not 'limit' in node:
		return None

	expr  = ''
	first = True

	for rule in node['limit']:
		op     = rule[0]
		arg    = rule[1]
		fmt    = None
		reason = None

		if op == 'ge':
			fmt    = '$VAR(@) >= {}'
			reason = 'Значение должно быть ≥ {}'

		if op == 'le':
			fmt    = '$VAR(@) <= {}'
			reason = 'Значение должно быть ≤ {}'

		if op == 'len-ge':
			fmt    = 'pattern $VAR(@) "^.{{{},}}$"'
			reason = 'Длина значения должна быть ≥ {}'

		if op == 'len-le':
			fmt    = 'pattern $VAR(@) "^.{{,{}}}$"'
			reason = 'Длина значения должна быть ≤ {}'

		if fmt != None:
			if not first:
				expr = expr + ' && '

			expr = expr + '(' + fmt.format (arg)

			if reason != None:
				reason = reason.format (arg)
				expr = expr + ' ; ' + escape (reason)

			expr  = expr + ')'
			first = False

	return None if expr == '' else expr

def get_vchk (node):
	ct = node['type'] if 'type' in node else 'string'
	vt = vyatta_type (node)

	if vt != 'txt' or ct == 'string':
		return None

	return 'vchk $VAR(@) "{}"'.format (ct)

def get_check (node):
	a = get_vchk (node)
	b = get_limits (node)

	if a == None:
		return b

	if b == None:
		return a

	return a + ' && ' + b

def write_checks (f, node):
	if 'enum' in node:
		first = True
		f.write ('syntax:expression: ($VAR(@) in ')

		for member in sorted (node['enum']):
			if not first:
				f.write (', ')

			f.write (escape (member))
			first = False

		if 'type' in node:
			expr = get_check (node)

			if expr != None:
				f.write (') || (' + expr)

		f.write (')\n')

	else:
		expr = get_check (node)

		if expr != None:
			f.write ('syntax:expression: ' + expr + '\n')

def write_helps (f, node):
	default = node['default'] if 'default' in node else None

	if 'enum' in node:
		f.write ('\n')

		for member in sorted (node['enum']):
			fmt  = 'val_help: _{}; {}\n'
			desc = node['enum'][member]

			if default != None and member == default:
				desc = desc + ' (по умолчанию)'

			f.write (fmt.format (member, desc))

	if 'type' in node and node['type'] == 'number':
		f.write ('\n')

		lo, hi = 0, 4294967295

		if 'limit' in node:
			for rule in node['limit']:
				op = rule[0]

				if op == 'ge':
					lo = int (rule[1])

				if op == 'le':
					hi = int (rule[1])

		fmt  = 'val_help: u32:{}-{}; {}\n'
		desc = node['desc']

		if default != None and isinstance (default, int):
			desc = desc + ' (по умолчанию ' + str (default) + ')'

		f.write (fmt.format (lo, hi, desc))

def build_conf (root, node):
	if not 'desc' in node:
		return

	kind = node['kind'] if 'kind' in node else 'group'

	intro = '# Autogenerated from Yonk JSON templates\n\n'
	path = os.path.join (root, 'node.def')

	with open (path, 'w', encoding = 'utf-8') as f:
		f.write (intro)

		if kind == 'attr' and 'mode' in node and node['mode'] == 'set':
			f.write ('multi:\n')

		if kind == 'node':
			f.write ('tag:\n')

		if 'priority' in node:
			f.write ('priority: ' + node['priority'] + '\n')

		f.write ('help: {}\n'.format (node['desc']))

		if kind != 'group':
			f.write ('type: ' + vyatta_type (node) + '\n')

			write_ref    (f, node)
			write_checks (f, node)

		if 'default' in node:
			fmt = '\ndefault: {}\n'
			f.write (fmt.format (escape (node['default'])))

		write_helps (f, node)

		if 'class' in node:
			fmt = 'update: /usr/lib/yonk/{} update $VAR(@)\n'

			if kind == 'group':
				fmt = 'update: /usr/lib/yonk/{} update\n'

			f.write ('\n')

			for c in node['class']:
				f.write (fmt.format (c))

def process_node (root, node):
	kind = node['kind'] if 'kind' in node else 'group'

	if not os.path.exists (root):
		os.mkdir (root)

	build_conf (root, node)

	if kind == 'node':
		path = os.path.join (root, 'node.tag')

		if not os.path.exists (path):
			os.mkdir (path)
	else:
		path = root

	if 'body' in node:
		process (path, node['body'])

	if 'class' in node:
		for c in node['class']:
			extra = json_load (os.path.join ('class', c + '.json'))
			process (path, extra)

def process (root, node):
	if node == None:
		return

	if not os.path.exists (root):
		os.mkdir (root)

	for name in node:
		process_node (os.path.join (root, name), node[name])

#
# Main
#

if len (sys.argv) < 2:
	print ("usage:\n\tgen-templates.py template.json ...\n")
	sys.exit (1)

for conf in sys.argv[1:]:
	process ('templates-cfg', json_load (conf))
